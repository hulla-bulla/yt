My game launcher is better than steam (or is it?)


Intro
You know a gamelauncher, that annoying thing you want to skip, yeah I made another one[a] in rust.
* But is it better than steam? 
* What features does it have? 
* How does it work? 
* How did I create this launcher? 
* Why did spend SO MUCH TIME to create this launcher? 
* #TODO add more here from the video. 


So many great questions, that will be answered. 


Selling points / Features Overview
* So It’s really fast
* It’s safe
* It’s compact
* Its stable
* It has (some) (in a small voice) … (pause) … settings
* It will probably be open source
* It has an AMAZING (sarcastic) ui. [b]Reveal later, I promise. 


Why
First of all, why is speed a critical feature?


The main usecase of the launcher if for alpha/beta-testers of my game. I want to be able to iterate fast and do lots of updates to my game and get feedback fast from the testers to improve my game faster. And tackle the bigger issues I dont even realize are there earlier to hopefully create a great game in the end. 


Some of you may recognize this concept also known as CI/CD or Continous integration, Continuous Deployment. [c]I’ll definitly make more videos regarding this, so if you’re interested press that subscribe button! 


My goal for later this year is going to be daily updates of the game.


If the testers are going to need to download the game and wait for an hour each time, depending on their internet speeds of course, it’s not going to be fun, and they’ll probably not test as much. 


When I’ve been testing the launcher now between updates it’s literally taken a some seconds to download an update around a couple hundered megabytes. [d]


How it works[e]
So how does it actually work? 
In general its a server client model, where you need at least one server and x number of clients connecting and downloading the game from that server using the launcher.[f]


Press play
So what happens when you press the play button?


If you just installed the launcher [g]and press play, the launcher checks the files in the game installation directory or creates, it and parent directories if it didn't already exist.


(pause)[h]


Not to go on a tangent here again, but this was one of the biggest hurdles I had creating this launcher, as I've done everything async for the filesystem and server calls. Who could know creating an async recursive function for creating all the parent directories could be an issue in an already hard language as Rust? Hmm. Anyway.


(pause)[i]
hashes
The launcher will scan all files and generate a hashfile in the installation directory. If our installation directory is empty, which it is because we just created it, the generated hashfile will look something like this. Not so interesting.


If we instead download [j]the server hash file, that's very small in size and takes no time to download, which is great. It will instead look something like this.


Ah thats better. As you can see it's just a bunch of text[k], dont worry, we wont be here for long if you're afraid of the dark terrors of text files.


On each line there are a filepath, hash and size. The filepath is relative from the installation directory, the hash is generated by the launcher and the size is the size in bytes, of the file on that line, just for a sanity check.


I dont even think I'm still using the last part, but might be in the future.


Compare hashes[l]
It then compares the server hash file to our client hash file, which is empty as we have no files yet. So the only conclusion the launcher can do is to download all the server files.


However if we had the game version 0.13 on our system,[m][n] the old version and an update of the game is released on the server. The updated version is 0.14. Then the hashfiles might look something like this.


The launcher compares the files and the hashes of those files. This process goes through line by line, file by file and compares them.


file is identical
If a file is identical on both sides, we dont need to do anything to that file. That file is the same and hasn't been changed in the update. This is great for big textures or models that take up lots of space and time to download and is one of the biggest reasons why the launcher is so fast.


file is not identical
If a file is not identical between client and server then that file is marked as need to download.


file is only on server
if a file is only on the server then its marked for download.


file is only on client
If a file is only on the client, then it'll be marked for removal, as it's not being used anymore. Otherwise the game will grow in space with unnecessary files. And we dont want that.


Result comparison
So the result of the comparison might look like this, which has completed all the steps we talked about earlier.


So keep these files, as they're the same in both versions of the game.


Download these new files in the new version, and remove the old files from the earlier version of the game, that we dont need anymore.


download async[o]
Okay, So then the download process starts, which downloads all the files and overwrites them if the files already existed on the client.


Download async
and simultaneously downloads and writes the files to disk, both async and on multiple threads.


The download process is async and multithreaded both for web calls and for writing to disk.
How relatively easy this was to get going in Rust using the async runtime Tokyo was really baffling to me. Tokyo seems to be the default async runtime to my understanding and worked generally great. It was only the recursive async function that I had to do some more tricks to get working.


Threads etc
The thread count is automatically set to your operating systems CPU threadcount -1 to not hang the system completely.


In general but no always you can get your thread count by multiplying the core count of your CPU by 2. So if you have 4 cores, you in general have 8 threads on you CPU.[p]


So, if you have
8 threads, then it'll use 7 threads by default for downloading and writing to disk.
16 threads -> using 15 of them.
32 threads -> 31 will be used.


Is this the ultimate performance? Probably not, if you have more ideas how to get more performance out of it let me know! However it's really fast and works great on the machines I've tested so far with everything from 6  to 16 Cores. #detail


Cleanup
After the download process the cleanup process begins and removes the files marked for removal.


Check[q]
So now you have hopefully all the files on disk from the server, so the launcher generates a client hashfile that should be the same as on the server or else something went wrong with writing to disk or while downloading a certain file.


Checksum[r]
This happens alot more than you think and is often why websites have a checksum next to the download link. And also to make sure the downloaded file isnt tempered with on the way to you.[s]


Result[t]
If any errors the launcher will compare and retry 3 times with a timeout as well and later show an error occured. I'll try to be specific here if its connectivity related or permissions on the file system related etc.


If everything went well, great! Now we can finally launch the game.[u]


Uninstall
To uninstall the game press the uninstall button. I know I felt like I had to explain that as well. It simply removes the files on disk. It will ask you if you want to remove your saved game files as well after pressing uninstall. No registry files or other jargon.




How is the server hashfile generated


#edit 111 zoom back up in after effects on the server hash file and question mark? arrows pointing to it, how is it generated


The server hash file is generated using my CI/CD pipeline that after it builds my game it directly generates a new hashfile on the server. Its also updating a static html with download links to the fully game zip files, for now, but I'm hoping to remove that with this launcher instead.


I want to do more here as posting to a discord channel, email etc whenever a update is released on the game.




Webserver and zoom in on server[v]


If we take a moment to take a quick overview and  zoom in on the server it has some different parts as well. 


I’m running proxmox and multiple virtual machines. 


* cloudflare
* firewall(s)
* SIEM (in progress)
* Traefik and middlewares
* proxmox
* vms
   * windows
   * ubuntu
      * docker
* * gitlab runners windows
   * build my game
* gitlab runner ubuntu
   * website hosting etc


Installation
To install the launcher, just download the launcher from the website—it's that simple. (awkward pause)


#edit 23 of fast paced instructions on the process to download install and launch the launcher then press the big play button.


(talking fast)
Then of course you need to download the launcher, launch the launcher installation and install it in the perfect location, then launch the launcher to launch the game download so you can hopefully launch the game through the game launcher eventually.


Happy surprise
This was actually a happy surprise, as I didn't know it was so easy to deploy an installation file for the launcheron windows from tauri. Tauri and/or cargo generates and compiles everything for you, so that was a really great experience.  


I can imagine it works similar on other OSes, but havent tried yet. And I'm not sure what platforms my game will launch on later as well.


CI/CD Pipeline Integration[w]


This launcher and related scripts fits seamlessly into my existing CI/CD pipeline. CI/CD is Continuous integration and continuous deployment, which automatically builds my game whenever I push new code or commits using git to my server. Let me know if you want to see more content about that.




- Do be able to get more iteration and CI CD with testers for my game faster.
    - People wont test as much if its a 1h download each time depending on internet speeds. or even 10min. Is it 5 seconds its much easier to get people on board and for my own sake.
- I have a CI system that builds the game and publishes everything automatically, let me know if you're interested in that and I'll make another video about it.
- I wanted to learn rust and this felt like a good first project, even though it turned out with more advanced features than I thought at first.


Selling points / Features Detailed


Performance[x]
But how fast is it REALLY??? It’s actually lightning-fast. Both downloading speeds and disk writing speeds as it’s utilizing both threads and asynchronous operations als known as async for disk writing and file downloading. This launcher waits for no one. 


So while downloading or making requests to the server there might be some delay as for all websites. [y]














Here are some AB testing 
* with and without async. 
* with and without multithreading[z][aa]


But you're on LAN


And some of you might think[ab], yeah but if your server is on the same network (which it is), what we call LAN or local area network, then of course your speeds would be great, as we have a much smaller way to go. [ac]And much less stuff in between. 


And to that I say yes. However I've tested this on celluar network and its still fast very fast[ad]. The speed mainly comes from not having to download all the files when I'm pushing an update per day for my game as well as async and multithreading. 


Safety
Memory safety[ae]
The launcher is built with memory safety in mind, thanks to Rust. Rust is one of the only memory safe programming languages. But dont just take my word for it. Both Linux and microsft use rust more and more. Linux in its kernel and microsoft has reportedly started using rust in their development. 


Why memory safety[af]
https://www.theregister.com/2023/04/27/microsoft_windows_rust/
“Microsoft is busy rewriting core Windows code in memory-safe Rust”
Hashes[ag]
I use a hashing algorithm beyond the usual suspects as md5, sha1 etc. This is used for comparing the client files to the files on the server. It could be done with file sizes or other hashing algorithms more like md5. But I chose the LONG and HARD way. 


(pause)[ah]


Someone in the room
Someone in the room: isnt that just another hashing algorithm you used that is kind of better but not really and you're making a whole point out of it as a feature, but it was just convenient for you to use whatever chatgpt recommended without even looking it up?


I'm listening to the person for about 10 seconds and looking at them, then looking into the ca[ai]mera.


Integrity and Collision Resistance:[aj]
No actaully there are some issues with earlier hashing algorithms.


While MD5 can be sufficient for checking file integrity against accidental corruption (like from disk errors), it's not secure against intentional tampering due to its collision vulnerabilities. If security is a concern and there's a risk of deliberate file manipulation, a more secure hash function like SHA-256 is recommended.[ak]


Encryption and Web Safety
HTTPS
The launcher is only using https which means it's encrypted traffic between your machine and the server. This is standard on the web and doesn't make you safe from middle-man-attacks or other evil things on the web, but it definitely makes it harder for an attacker to do anything basically and is significantly raising the barrier for potential attackers.


TLS1.3[al]
It's also enforcing TLS 1.3, which is an encryption standard used by HTTPS and accepting no version less than 1.3 for security reasons and best practices. This puts some requirements on the webserver, hosting the files, but that wont be an issue for my configuration or my amazing server here.


Tangent[am]
A little bit of a tangent here, but a server on premise etc might sound like a lot and usually looks like this when you're talking about it.
But mine, often more powerful with 30TB storage, backups to a second location etc looks more like this.Not as glorious but definetly much much faster and cheaper than in the cloud without spending about 2k a month for how I'm using this.


If you want more content regarding that sort of thing let me know as well. Okay lets get back.


Compact
The launcher is compact or small... (pause)... but it's still effective and it does its job. and honestly it doesn't really matter the size of the codebase... (pause) (look to the right on mathilda) [an]


Its less than 2k lines of code. Which means it's definitly easier to maintain and there's no reason to make it bigger than it have to be with lots of classes of other classes. It could be a big object oriented mess. So i'll try to keep it small for as long as possible as its responsibilities and featureset is still pretty small.


This is not the final final version 2.0 tokyo drift and I'll probably do lots to this launcher while editing this video. But it should be in a pretty good place. It's robust and ready to grow as we enhance it further.[ao]


Stable
The launcher is surprisingly stable. I’ve never had it crash on me even once. [ap]


Settings
There are some but not many settings. You can set number of threads used by the app, and the installation location for the game. otherwise it'll default to where the launcher is installed.


Open source - Soon (probably)
Probably soon. I haven't decided fully yet but would definitely want the core of this to be fully open source to get more eyes on the small madness that I've managed to create here. There's no god like coding, and probably overlooked a bunch of stuff.


I also really like the idea of helping others with their madness whenever they dont want to take the easy route and just putting their game on steam.


Git commits[aq]
And I’ll definitly need to clean up the git history, or just nuke it, because there are some questionable commits made.


UI and looks
“But with all those features it must look amazing, right?”


Yeah….[ar]
Yes I know, I’m amaaazing at UI design, but you can say that I gave up before starting. So if you have suggestions for how to make it not look like…. this….. let me know! [as]


Comparison with launchers
Why create your own launcher, aren't there existing ones?[at]


List of launchers
Most popular ones are steam ofc epic games etc. Fully functional and I could use any one of them, but whats the fun in that? So in a second atempt at making my life more miserable i chose to learn rust, code my own launcher to hopefully gain something. 


Okay so lets take a look. What game launchers exists? 
* epic games store
* steam
* xbox
* gog galaxy
* microsoft store
* amazon games
* ea
* ubisoft connect
* battle.net
* itch.io


but is it actually better, lets compare.[au]


What is a game launcher
First we need to settle what is a game launcher? A game launcher can download, install and launch your game.


Side by side compariseon with my game launcher and steam or other game launcehrs
Trapcard. Rust - gameover
So which are made in rust. steam? epic games? origin? no no no no! this beauty? thats right. game over.


Compare with steam


So if we compare downloading this random game and mine. Se whos faster. And DONE. That's right. "Oh but hullabulla thats because that other piece of trash (starfield) on steam was over 100GB in size. " SHHH sh. silence.


Speed Test
Let’s put it to the test: downloading a game on our launcher versus Steam. And... we’re faster!
#edit 16 Real-time download race between our launcher and Steam, ending with our success.


Who's Prettiest (UI)


So whos the prettiest? This might be a hard one, but I definitely know who´s the ugliest one. #edit 17 footage of origin.


whos the prettier one -> steam
whos the faster one?= steam


Other differences
gpt: explain and make these bulletpoints more robust and detailed.
- fast
- speed
- stability
- users
- money spent developing


Progress Bar[av]
Includes a progress bar that updates in real time, reflecting the current state of downloads or installations. Real-Time Non-Blocking Updates


Direct Game Launching[aw]
Once an update or installation completes, launch your game directly from the launcher, with no delays or additional steps.




High-Performance File Management
Uses cutting-edge hashing and network request optimization to manage files efficiently and securely.
#edit 28 Animated depiction of smart file management strategies in action.


Interactive Update Mechanism
        - Users can initiate game updates or installations via a simple user interface, enhancing engagement and providing clear operational feedback.
- **Event-Driven Communication:**
    
        - Utilizes custom events to handle and display download progress, keeping users informed of the current state of game update processes.
- **Asynchronous Operations:**
    
        - Supports asynchronous tasks for downloading and installing games, ensuring the user interface remains responsive during these processes, with robust error handling for reliability.
- **Direct Game Launching:**
    
        - Facilitates direct launching of games from the launcher once updates or installations are complete, with state management to prevent launching before readiness.
- **Memory and Type Safety:**
    
        - Implements Rust’s strong type system and memory safety features to minimize common security issues, enhancing overall software security.
- **Modular and Extensible Design:**
    
        - Built with modularity in mind for easy expansion or modification of features, leveraging Tauri for a secure and lightweight application.
- **Customizable User Interface:**
    
        - Offers a customizable and responsive design, suitable for different game themes or branding requirements.
- **Automated and Scheduled Updates:**
    
        - Capable of performing automated background checks for updates, ensuring the game is always current without manual input.
- **Cross-Platform Compatibility:**
    
        - Designed to operate across different operating systems, utilizing Rust’s cross-platform support and Tauri’s web technology.
- **File Integrity Verification:**
    
        - Uses SHA-256 and BLAKE3 hashing to verify file integrity during downloads, preventing corruption and unauthorized modifications.
- **Smart File Management:**
    
        - Manages files efficiently by only downloading or deleting files as needed based on hash comparisons, reducing bandwidth and storage usage.
- **Concurrent File Operations:**
    
        - Employs asynchronous I/O and multitasking to handle file operations concurrently, speeding up updates and improving user experience.
- **Environmental Configuration:**
    
        - Adapts launcher functionality based on environment variables and configurable settings, tailored for different user setups or stages of development.
- **Directory Management and Creation:**
    
        - Automatically manages directories and paths, ensuring proper organization and reducing manual setup requirements.
- **Dynamic Event Emission:**
    
        - Emits events to the frontend during operations like file downloading, providing a responsive UI that updates according to backend activity.
- **High-Performance Hash Computation:**
    
        - Incorporates multi-threaded BLAKE3 hash computation for fast and efficient checksum generation.
- **Optimized Network Requests:**
    
        - Efficiently handles network requests, minimizing data transfer by using metadata comparisons before file operations.
- **Logging and Debugging:**
    
        - Includes detailed logging to support debugging and trace operations, enhancing maintainability and diagnostics.
- **Asynchronous and Recursive Directory Visits:**
    
        - Supports non-blocking file operations across large and nested directory structures, facilitating comprehensive file management.






**Additional Details**


- **Version Tracking:** Displays the current version of the launcher on the UI, keeping users informed about the software version they are using.
- **Feedback Mechanisms:** Placeholder for integrating user feedback directly through the launcher, potentially linking to a Discord channel or other social platforms for community engagement.


This feature list aims to cover both the technical capabilities and user experience enhancements provided by your game launcher, making it a comprehensive tool for gamers looking to manage their game installations and updates effectively.






Why use rust?
I've never used rust before.


LEARNT RUST AND CREATED A GAME LAUNCHER UPDATER FOR MY GAME BUT COULDVE JUST USED STEAM I GUESS, BUT I THOUGHT IT WOULD BE FUN AND EASY TO LEARN RUST... HEHE.. HE. HE....
Rust AWESOME


Lots of videos and images of rust and or gamelaunchers?. fast paced with music.
* #edit 31 Rust memory safe articles
* #edit 32 Even microsoft is using rust microsoft implements rust
* #edit 33 linux kernel and gnu tools implemented in rust
* videos of rust
* crablang
* rust videos
* eco system with cargo[ax]
why use rust instead of cpp
    - have used some imgui with cpp like hazel and thecherno does. (ray tracer, show edit.) If you haven't checked out his channel yet DO IT.
    - What is rust
Why i choose tauri


I'm using V1 as when I started the launcher V2 wasn't in beta yet. Otherwise I might have considered it as I kind of like to bleed on the edge.
#edit 103 tauri home page the beta for tauyri 2.0 has launched. https://v2.tauri.app/blog/tauri-2-0-0-beta/


#edit 35 show home page
#edit 36 show documentation of tauri


Features docs
look at all these features from tauris website. Whats not to like? The docs are greeeeaat (not so sure it's great) but could be better. That last part might have to do with me not knowing rust beforehand.


Brownfield
"Compatibility with any front-end framework means you don't have to change your stack."


#edit https://tauri.app/v1/guides/getting-started/setup/


Which is great and I chose solid, to learn something new on top of the new. Haven't gotten past getting things to work yet so I would definitely fail a nextjs solid quiz right now. I'm not a javascript person at heart and tend to avoid it unless I have to.


You can choose basically any javascript framework and others. The ones listed on their website are
*
* Next.js
* Qwik
* SvelteKit
* Vite


#edit 102 The cargo create-tauri-app choose


But in their cargo create-tauri-app you can choose between
* vanilla javascript
* vue
* svelte
* react
* solid
* angular
* preact ( i have no idea what this is and simply not the energy to even begin to research. I'm okay with some things remaining a mystery to me, and javascript framworks rank pretty high on my not-the-need-to-know list.  )


You also choose between package manager like
* npm
* pnpm (which I chose and hadn't used before. Seems simply like a faster version of npm in my understanding.   )
* yarn
* bun


And between javascript and typescript, where I tried to be a good boy and chose typescript.








Security
"Front-of-mind for the Tauri Team driving our highest priorities and biggest innovations."


No Server Required
- **Feature Overview**: Tauri applications do not require a server backend, eliminating common network vulnerabilities.
- **Detailed Explanation**: By omitting the need for server communication, Tauri reduces the physical and virtual footprint of applications. This approach minimizes the attack surface by removing network-related vulnerabilities like TCP port sniffing or external process attacks.


Language Features of Rust
- **Feature Overview**: Tauri is built using Rust, which is known for its memory safety features.
- **Detailed Explanation**: Rust’s design prevents a range of common security issues, such as buffer overflows and use-after-free errors, making Tauri applications inherently safer.


Dynamic Ahead of Time Compilation (AOT)
- **Feature Overview**: Tauri employs a dynamic AOT compilation strategy during the initial app startup.
- **Detailed Explanation**: This compilation strategy generates unique code references for each session, which remain static during that session. This enhances security by making static attacks much harder to execute.


Function Hardening
- **Feature Overview**: Tauri uses advanced ASLR techniques for function hardening.
- **Detailed Explanation**: By randomizing function names and using unique identifiers for function pointers, Tauri prevents attackers from exploiting predictable memory addresses, thus enhancing protection against memory corruption exploits.


Kamikaze Function Injection
- **Feature Overview**: Incorporates a unique security feature where functions are injected at runtime and are designed to be used once.
- **Detailed Explanation**: These functions are wrapped in closures with randomized handles and are discarded after execution, which helps in protecting against reuse attacks in web environments.


Bridge, Don't Serve
- **Feature Overview**: Tauri uses a message-passing bridge instead of direct function calls to enhance security.
- **Detailed Explanation**: This architecture minimizes risks associated with exposing functions directly, instead using a controlled message bridge that safely conveys commands and data.


One Time Pad Tokenization and Hashing
- **Feature Overview**: Implements OTP for hashing critical messages between the UI and backend.
- **Detailed Explanation**: This method uses a single-use cryptographic key for hashing, significantly enhancing the security of data transmissions. Tauri is exploring additional entropy sources to further strengthen this feature.


System Features
- **Allowing API**
  - **Feature Overview**: Provides granular control over which API functions are exposed to the UI.
  - **Detailed Explanation**: This selective enabling of API functions prevents unnecessary code from being included in the app, reducing the overall attack surface.
- **Content Security Policy Management**
  - **Feature Overview**: Automatically manages content security policies to prevent unauthorized code execution.
  - **Detailed Explanation**: By injecting CSPs into the application, Tauri blocks external scripts or unauthorized content that could compromise the app.


Decompilation is Difficult
- **Feature Overview**: Tauri apps are designed to be resistant to decompilation.
- **Detailed Explanation**: This resistance makes reverse engineering the app significantly more challenging, requiring specialized skills and deterring casual hackers.


Ecosystem
- **Build Pipelines and Artifact Authenticity**
  - **Feature Overview**: Uses automated yet closely monitored build pipelines to maintain artifact integrity.
  - **Detailed Explanation**: These processes ensure that every release is rigorously checked by human supervisors before being published, maintaining high security standards.
- **Resilient PR and Approval Processes**
  - **Feature Overview**: Maintains stringent PR and code approval processes.
  - **Detailed Explanation**: This procedure ensures all code changes are reviewed for security implications, keeping the project secure as it evolves.


Future Work
- **Signed Binaries**
  - **Feature Overview**: Plans to implement signing of all application binaries.
  - **Detailed Explanation**: Signing will verify the authenticity and integrity of distributed binaries, making unauthorized modifications easily detectable.
- **Post-Binary Analysis**
  - **Feature Overview**: Intends to utilize industrial-grade penetration testing tools.
  - **Detailed Explanation**: These tools will be used to assess and fortify the security of the binaries after they are built.
- **Post-Binary Enhancement**
  - **Feature Overview**: Future tools will enhance security after the build process.
  - **Detailed Explanation**: These tools will provide unprecedented security features to further protect against evolving threats.




FLOSS
"Relicensing and redistribution is possible thanks to MIT or MIT/Apache 2.0 licensing where applicable."


Bundle size
"By using the OS's native web renderer, the size of a Tauri app can be less than 600KB."


#edit 102 meme of the guy saying nice.
Nice.


Cross platform
"Bundle binaries for all major desktop platforms (mobile coming soon)."


Cross-Platform Compilation


- **Feature Overview**: Tauri's architecture relies on native libraries, which restricts the ability to perform cross-compilation directly.
- **Detailed Explanation**: Due to these limitations, the recommended approach for building applications for different platforms is to use CI/CD pipelines such as GitHub Actions, Azure Pipelines, or GitLab. These tools allow simultaneous compilation for various platforms, streamlining the release process.


Tauri GitHub Action


- **Feature Overview**: A GitHub Action specifically designed to build Tauri applications across supported platforms and automate the release process.
- **Detailed Explanation**: This GitHub Action simplifies the setup process, ensuring that your application compiles correctly on macOS, Linux, and Windows for each pull request and pushes to the repository. It also handles the creation of new releases on GitHub, making the distribution of your application effortless.


Code Signing


- **Feature Overview**: Tauri provides detailed guidance for setting up code signing on both Windows and macOS using GitHub Actions.
- **Detailed Explanation**: Code signing is crucial for ensuring the integrity and origin of your software. Following the specific guides for each platform helps secure your application and builds trust with your end users.


Configuration


- **Feature Overview**: Configuration options for Tauri GitHub Action include specifying paths for config, distribution, and icons.
- **Detailed Explanation**: These configurations allow for precise control over the build process in a GitHub Action workflow, ensuring that the build environment is correctly set up according to the specific needs of your application.


How to Trigger


- **Feature Overview**: The GitHub Action for Tauri can be triggered by events such as pushes to specific branches or tags.
- **Detailed Explanation**: This flexibility allows you to automate the build and release process based on your development workflow. For example, pushing to a "release" branch or tagging a commit can automatically trigger the compilation and release processes.


Example Workflow


- **Feature Overview**: An example workflow is provided to demonstrate the setup and execution of a GitHub Action for Tauri.
- **Detailed Explanation**: This workflow includes steps for checking out the code, setting up the environment, building the application, and publishing it as a GitHub release. It ensures that your application is built for all targeted platforms, including newer ARM-based Macs and traditional x86 architectures.


GitHub Environment Token


- **Feature Overview**: Explains the use of the GitHub Token within GitHub Actions workflows.
- **Detailed Explanation**: The GitHub Token is essential for actions like creating releases and interacting with the repository. It's automatically managed by GitHub, ensuring security and simplicity in its usage.


Experimental: Build Windows apps on Linux and macOS


- **Feature Overview**: Discusses the experimental capability of building Windows applications from macOS and Linux environments using NSIS.
- **Detailed Explanation**: This feature is particularly useful when traditional CI environments are unavailable. It uses NSIS to enable cross-platform builds of Windows applications from non-Windows hosts, though it's noted as experimental and may not work for all setups.


Built on rust
"With performance and security at the center, Rust is the language for the next generation of apps."




Happy surprises






Features of the game launcher in the future
Not to confuse with tauri, features of the game launcher in the future.


Compression
#edit 34 steam unpacking while downloading
Steam is famous of course on how they takes all your cpu-cores capture whenever you're downloading a game as they're unpacking and downloading at the same time. This puts more processing on the clients, which is totally reasonable when you have so many clients, and maybe even for this project.


#edit 115 ae compress each file or a big blob
But I'm not sure on the best way forward. A big zip blob defeats the purpose of just downloading the files that changes. I can create a big blob and split that up, but that would also defeat the purpose as one file changes and all the smaller blobs changes from the big blob.


I can compress each file separately, however I might not get that much out of it for the smaller files. I can group smaller files into a blob or do some smarter grouping of files, who knows.


So i'm not totally sure how to proceed here. If you have ideas, let me know!


#edit 116 docker downloading only changes
I know docker does something smart by splitting up somehow and downloading only chunks that have changed. Might look into that.


#edit 117 unreal packaging settings
As I'm using unreal for my game the packaging settings also affects how to chunk the download files. As I've said before I'm generally for more files and only updating the ones that've changed to get more iteration speed and iteration testing speed from alpha/betatesters etc.




Installing the game as an application in windows
As of now the launcher simply downloads the game to a folder and launches the app. It would be nicer to have it installed as a game in windows, where you also can uninstall the game.


Tests
Another big feature is no tests. Im kidding of course. There are no tests as of now.  So I don't actually know if it works properly outside my system. I've done manual tests of course, but no robust ci/cd pipeline for this launcher as of yet. Honestly I haven't gotten into how to test in rust, will need to read or watch some tutorials but it should be pretty simple i guess. Tauri have both the javascript end and the rust end, so that might complicate things a bit, I'll let the future version of myself handle that.






How to make your own game launcher


I'm thinking about making this project open source, but idk yet. If you want to make your own game launcher, similar to this project you have two simple paths.


Path 1
One path is made of concrete and butterflies and is only valid for the guru jedi masters of coding. So if you fit in that description and know everything about coding then you'll have a good time. Congratulations. Why are you here? I'm kidding, please dont leave me.[ay]


Path 2
And for the rest of us mortals... You see this jungle? Yes. (pause) (in a darker voice) There's no escaping the jungle.


(fast)
So in short:


- learn rust
- cry
- more rust
- more cry


#edit image of bob marley no rust no cry or stroke over no woman no cry
(sing no rust rust no cry)


My path was


I started small and got through some tutorials by lets get rusty, boilerplate and my swedish bro tantan.


#todo
- Start to code
- familiar with tauri or other gui ui app
- show the code.
- go through the code[az]




Git animation


#edit 100 git checks and commits over time. In a nice graph or git animation. Lookup!


gpt: dont know where this edit could fit in the script, find a good place where it makes sense.


Wrap-up
No, of course its not better than steam, its just a silly comparison to get to talk about this awesome stuff. But it is faster in some regards with 1 user (me), which is not scalable, and not relevant for that kind of comparison anyway.


#edit footage on transferring something to my server in windows explorer.
Now the bottleneck for the server on my lan is still my 1Gbps ethernet card in my pc, the server and swtich etc are 10Gb. So that's also an upgrade for the future.




Would I do it again
I mean yes. I did it mainly to get into rust and now I'm feeling so much more #todo


4/5 potatoe[ba][bb]s. Very nice.




Outro
I know it's been a minute since my last upload, much longer than I wanted. But I've been really busy, changing dayjob, apartment etc among learning more c plus plus for my game, so i So I did the only reasonable thing to do and created this game launcher and about 5 other projects, that I might talk about in the future. Also take what I’m saying in these videos with a grain of salt, i’m trying to make these really techy videos at least a bit entertaining. 


Let me know what you think. I’m still finding out what I'm interested in and what to dive deeper into. I've got a long list and little time to do it. So your feedback is very appreciated! Have a great one! See ya. 














[a]show it in your hand or something and track it
[b]#Edit pokemon black squary with questionmark
[c]#Edit of gitlab inamation of devops or cicd
[d]#edit compare two users one frustrated waiting and hour and one happy.
[e]18 of graph in after effects when talking about this.
[f]#edit after effects basic multiple clients connecting to server
[g]#edit 19 footage of pressing play in the launcher on an empty project. progressbar etc.
[h]#edit 20 pause the video. and big pause on screen with tv flicker effect.
[i]#edit 21 the footage keeps rolling and the big pause stops.
[j]#edit 122 syrosor tom fil.
[k]#edit 22 after effects text of how the hashfile looks.
[l]#edit 124 compare server client
[m]#edit 125 client file is not empty
[n]#edit 126 show result is to download all files
[o]#edit 112 download async
[p]#edit 113 cpu count and threads
[q]#edit 114 idk
[r]#edit 118 ubuntu checksum ont their website
[s]#edit 119 shadow figure in the middle of the connected thing to you. changing the file and sending to you.
[t]#edit 121 show errors in launcher
[u]#edit 120 press play and launch the game show how it comes up on screen
[v]#edit zomm in on server icon and see proxmox, gitlab, docker, traefik etc. how it works in tandem. gitlab-runner
[w]#edit 24 Visual flow of CI/CD integration, showing code commits triggering automatic builds and deployments.
[x]More content here
[y]#edit add initial delay for websites
[z]how?
[aa]#edit 130 show how fast with fire
[ab]#edit 2 downloading using cellular network
[ac]#edit zoom out LAN computer to Internet to server with lots of switches between
[ad]#edit Show comparison between transferring files lan and cellular, task manager network view, not file transfer with explorer, but use the rust launcher.
[ae]#edit tidningsartiklar.
[af]#edit 132 show why we want memory safety
[ag]#edit 3 of music pumping in background since before as well
[ah]#edit 4 music stops.
[ai]#edit 5 fast cut here for comedic effect.
[aj]#edit 6 issues with md5 and why its not used before.
[ak]#edit 7 Visual explanation of file hashing and its importance in cybersecurity.
[al]#edit 8 of server.
#edit 9 Dynamic illustration of TLS 1.3 encryption in action, with a backdrop of a high-tech server environment.
[am]#edit 10 of high quality server.
#edit 11 footage of our actual server.
[an]#edit 13 mathilda does "mmhhmm". 
#edit 12 fast cut back to talking.
[ao]#edit 14 Code snippets scrolling, showcasing the compact and efficient code base.
[ap]#edit 129 (cries in c plus plus) on the screen
[aq]#edit 133 show git history animation
[ar]#edit small fart sound when reveal
[as]#edit (fart sound on this above)
[at]Makar sense om detta kommer efter detailed features och innan "how it works" för mig, när man har alla features redan i huvudet
[au]#edit 29 of people saying game launcher or installer
#edit 30 of steam, ubisoft, epic games downloading and installing games.
[av]#edit 25 Progress bar filling up swiftly as a game installs, with dynamic text updates.
[aw]#edit 27 Quick transition from download completion to game startup.
[ax]helt rätt!
[ay]hahaha
[az]jättebra och koncis sammanfattning!
[ba]potato-animation som blir kännetecken för din kanal?
[bb]#edit potato animation